/**\n * Notification System\n */\n\nexport type NotificationType = \"success\" | \"error\" | \"warning\" | \"info\";\nexport type NotificationPriority = \"low\" | \"normal\" | \"high\" | \"urgent\";\n\nexport interface Notification {\n  id: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  priority: NotificationPriority;\n  timestamp: Date;\n  read: boolean;\n  actionUrl?: string;\n  actionLabel?: string;\n}\n\nexport interface NotificationPreferences {\n  email: boolean;\n  push: boolean;\n  inApp: boolean;\n  categories: {\n    orders: boolean;\n    inquiries: boolean;\n    messages: boolean;\n    system: boolean;\n  };\n}\n\n/**\n * Notification Manager\n */\nexport class NotificationManager {\n  private notifications: Notification[] = [];\n  private listeners: ((notification: Notification) => void)[] = [];\n  private maxNotifications: number = 100;\n\n  addNotification(\n    type: NotificationType,\n    title: string,\n    message: string,\n    priority: NotificationPriority = \"normal\",\n    actionUrl?: string,\n    actionLabel?: string\n  ): string {\n    const notification: Notification = {\n      id: `notif-${Date.now()}-${Math.random()}`,\n      type,\n      title,\n      message,\n      priority,\n      timestamp: new Date(),\n      read: false,\n      actionUrl,\n      actionLabel,\n    };\n\n    this.notifications.unshift(notification);\n\n    // Keep only maxNotifications\n    if (this.notifications.length > this.maxNotifications) {\n      this.notifications.pop();\n    }\n\n    // Notify listeners\n    this.listeners.forEach((listener) => listener(notification));\n\n    return notification.id;\n  }\n\n  getNotifications(unreadOnly: boolean = false): Notification[] {\n    if (unreadOnly) {\n      return this.notifications.filter((n) => !n.read);\n    }\n    return [...this.notifications];\n  }\n\n  markAsRead(notificationId: string): void {\n    const notification = this.notifications.find((n) => n.id === notificationId);\n    if (notification) {\n      notification.read = true;\n    }\n  }\n\n  markAllAsRead(): void {\n    this.notifications.forEach((n) => (n.read = true));\n  }\n\n  removeNotification(notificationId: string): void {\n    const index = this.notifications.findIndex((n) => n.id === notificationId);\n    if (index > -1) {\n      this.notifications.splice(index, 1);\n    }\n  }\n\n  clearAll(): void {\n    this.notifications = [];\n  }\n\n  subscribe(listener: (notification: Notification) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  getUnreadCount(): number {\n    return this.notifications.filter((n) => !n.read).length;\n  }\n}\n\n/**\n * Notification Templates\n */\nexport class NotificationTemplates {\n  static orderConfirmed(orderNumber: string): Notification {\n    return {\n      id: `notif-${Date.now()}`,\n      type: \"success\",\n      title: \"Order Confirmed\",\n      message: `Your order ${orderNumber} has been confirmed`,\n      priority: \"normal\",\n      timestamp: new Date(),\n      read: false,\n      actionUrl: `/orders/${orderNumber}`,\n      actionLabel: \"View Order\",\n    };\n  }\n\n  static orderShipped(orderNumber: string, trackingNumber: string): Notification {\n    return {\n      id: `notif-${Date.now()}`,\n      type: \"info\",\n      title: \"Order Shipped\",\n      message: `Your order ${orderNumber} has been shipped. Tracking: ${trackingNumber}`,\n      priority: \"normal\",\n      timestamp: new Date(),\n      read: false,\n      actionUrl: `/tracking/${trackingNumber}`,\n      actionLabel: \"Track Package\",\n    };\n  }\n\n  static inquiryResponse(inquiryId: number): Notification {\n    return {\n      id: `notif-${Date.now()}`,\n      type: \"info\",\n      title: \"New Message\",\n      message: \"You have a new response to your inquiry\",\n      priority: \"normal\",\n      timestamp: new Date(),\n      read: false,\n      actionUrl: `/inquiries/${inquiryId}`,\n      actionLabel: \"View Inquiry\",\n    };\n  }\n\n  static paymentFailed(orderNumber: string): Notification {\n    return {\n      id: `notif-${Date.now()}`,\n      type: \"error\",\n      title: \"Payment Failed\",\n      message: `Payment for order ${orderNumber} failed. Please try again.`,\n      priority: \"high\",\n      timestamp: new Date(),\n      read: false,\n      actionUrl: `/checkout/${orderNumber}`,\n      actionLabel: \"Retry Payment\",\n    };\n  }\n\n  static systemMaintenance(): Notification {\n    return {\n      id: `notif-${Date.now()}`,\n      type: \"warning\",\n      title: \"System Maintenance\",\n      message: \"System maintenance scheduled for tonight. Service may be unavailable.\",\n      priority: \"high\",\n      timestamp: new Date(),\n      read: false,\n    };\n  }\n}\n\n/**\n * Email Notification Service\n */\nexport class EmailNotificationService {\n  async sendNotification(\n    email: string,\n    subject: string,\n    message: string,\n    htmlContent?: string\n  ): Promise<boolean> {\n    try {\n      // In production, integrate with email service (SendGrid, AWS SES, etc.)\n      console.log(`Sending email to ${email}: ${subject}`);\n      return true;\n    } catch (error) {\n      console.error(\"Failed to send email notification:\", error);\n      return false;\n    }\n  }\n}\n\n/**\n * Push Notification Service\n */\nexport class PushNotificationService {\n  async sendNotification(\n    userId: string,\n    title: string,\n    message: string,\n    data?: Record<string, string>\n  ): Promise<boolean> {\n    try {\n      // In production, integrate with push notification service (Firebase, OneSignal, etc.)\n      console.log(`Sending push notification to ${userId}: ${title}`);\n      return true;\n    } catch (error) {\n      console.error(\"Failed to send push notification:\", error);\n      return false;\n    }\n  }\n}\n\n/**\n * In-App Notification Service\n */\nexport class InAppNotificationService {\n  private manager: NotificationManager;\n\n  constructor() {\n    this.manager = new NotificationManager();\n  }\n\n  notify(\n    type: NotificationType,\n    title: string,\n    message: string,\n    priority?: NotificationPriority\n  ): string {\n    return this.manager.addNotification(type, title, message, priority);\n  }\n\n  getNotifications(unreadOnly?: boolean): Notification[] {\n    return this.manager.getNotifications(unreadOnly);\n  }\n\n  markAsRead(id: string): void {\n    this.manager.markAsRead(id);\n  }\n\n  subscribe(listener: (notification: Notification) => void): () => void {\n    return this.manager.subscribe(listener);\n  }\n}\n
